\documentclass{ximera}
\input{../../../preamble.tex}

\author{Zack Reed}
\title{Matrix Multiplication}

\begin{document}

\begin{abstract}

\end{abstract}
\maketitle

We now continue this theme of linear transformations to develop intuition for how we might multiply matrices together. The main idea is that when matrices multiply, you combine the effects of each matrix transformation together, and matrix multiplication enables you to determine what the total transformation is rather efficiently.

\begin{exploration}\name{Sequencing Transformations - Matrix Multiplication}

    We've now got a good handle on performing singular transformations of vectors using matrices. But what if we want to perform multiple transformations on a vector?

    Suppose we wanted to take our original smiley face, stretch it out in the vertical direction, rotate it $60^\circ$, and then reflect it about the $y$-axis. 

    We could do this in two ways:
    \begin{enumerate}

        \item Perform each transformation one at a time, and then apply the next transformation to the result.
        
        \item Determine the transformations of the standard basis vectors for the entire sequence, and use that single matrix to transform the original smiley face.

    \end{enumerate}

    Both of these procedures will get us the same final transformation, and using the first method to figure out the second method gives us another key operation: matrix-matrix multiplication (also just called matrix multiplication).

    Let's take each step in sequence, track the smiley face along the way, and use the steps together to make a final transformation. 

    \begin{example}

        Let's figure out how to do the first two operations in sequence, first a vertical stretch by a factor of $2$, and then a $60^\circ$ rotation.

        We know that a vertical stretch by a factor of $2$ is given by the matrix $S=\begin{bmatrix} 1 & 0 \\ 0 & 2 \end{bmatrix}$, and a $60^\circ$ rotation is given by the matrix $R=\begin{bmatrix} \cos 60 & -\sin 60 \\ \sin 60 & \cos 60 \end{bmatrix}$.

        Doing the two transformations in tandem means first applying the stretch, then applying the rotation \emph{on the stretched smiley face}.

        Let's first do each transformation in MATLAB, first the vertical stretch. For ease, we'll first load a separate file called \texttt{face\textunderscore points.mat} that contains the smiley face points as a single matrix.

        \begin{verbatim}

            load +linalg/face_points.mat
        
            S = [1 0; 0 2];
            for i=1:length(face_points)
                face_points(i,:)=S*face_points(i,:)';
            end
            linalg.plot_img_points(face_points)

        \end{verbatim}

        That should yield a smiley face that is stretched vertically by a factor of $2$.

        \begin{center}
            \includegraphics[width=\textwidth]{face_stretch.png}
        \end{center}

        Next, if we just re-load \texttt{face\textunderscore points} and run the same code (but for a rotation matrix), we won't keep the stretching. We would just get a $60^\circ$ rotation of the original smiley face like below.

        \begin{verbatim}

            R = [cosd(60) -sind(60); sind(60) cosd(60)];
            for i=1:length(face_points)
                face_points(i,:)=R*face_points(i,:)';
            end
            linalg.plot_img_points(face_points)
        \end{verbatim}

        \begin{center}
            \includegraphics[width=\textwidth]{face_rotate.png}
        \end{center}

        Instead, we have to first apply the stretching, then keep the result and apply the rotation. 

        If we do one transformation and then the other right after, we could get the following: 

        \begin{verbatim}
                
                load +linalg/face_points.mat
    
                S = [1 0; 0 2];
                R = [cosd(60) -sind(60); sind(60) cosd(60)];
                for i=1:length(face_points)
                    face_points(i,:)=S*face_points(i,:)';
                end
                linalg.plot_img_points(face_points)

                for i=1:length(face_points)
                    face_points(i,:)=R*face_points(i,:)';
                end
                linalg.plot_img_points(face_points)
        \end{verbatim}

        Importantly, in between the for loops you see the intermediate stretching step. After the first loop, the vectors were all stretched, then they were further rotated in the second loop.

        This yeilds the following smiley faces:

        %do a side-by-side of the stretched and rotated smiley faces, within one single figure

        \begin{center}
            \includegraphics[width=\textwidth]{face_stretch.png}
        \end{center}

        \begin{center}
            \includegraphics[width=\textwidth]{face_stretch_rotate.png}
        \end{center}

        The final smiley face is the result of the two transformations in sequence.

        \begin{remark}

        This is an example of what is called \emph{function composition}, where you chain multiple functions together in an input$\rightarrow$output$\rightarrow$input$\rightarrow$output sequence, progressively transforming the original inputs until you reach a final output.

        \begin{tikzpicture}

            % Draw sets A, B, C
            \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);
            \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);
            \draw[fill=blue!20!white, draw=black, thick] (4,0) ellipse (1.5cm);
            
            % Labels for sets A, B, C
            \node at (-4,1.8) {\textbf{X}};
            \node at (0,1.8) {\textbf{X'}};
            \node at (4,1.8) {\textbf{X''}};
            
            % Elements inside sets
            \filldraw[red] (-3,0) circle (3pt) node[below] {\textbf{v}};
            \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{S(v)}};
            \filldraw[red] (3.5,-.5) circle (3pt) node[below] {\textbf{R(S(v))}};
            
            % Arrows for functions f, g, gof
            \draw[->, thick, purple] (-3,0.2) .. controls (-1,1.2) .. (1,.7) node[midway, below] {\textbf{S}};
            \draw[->, thick, purple] (1,.7) .. controls (2,1.5) .. (3.5,-.3) node[midway, above] {\textbf{R}};
            \draw[->, thick, purple] (-4,-1.7) .. controls (0,-2.5) .. (4,-1.7) node[midway, below] {\textbf{RoS}};
            
        \end{tikzpicture}

        In the above diagram, $X$ is the original data, $X'$ is the data after the stretching transformation, and $X''$ is the data after the rotation transformation. The arrows represent the transformations that progressively alter the data, and the final arrow represents the composition of the two transformations.

    \end{remark}

    Our goal is to find a systematic way of representing the composite transformation as a single matrix. From this example, let's track the transformations of the standard basis vectors.

    We start with the standard basis vectors $\vec{e}_1=\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $\vec{e}_2=\begin{bmatrix} 0 \\ 1 \end{bmatrix}$, and apply the transformations in sequence.

    The stretching transformation matrix is $S=\begin{bmatrix} 1 & 0 \\ 0 & 2 \end{bmatrix}$, which tells us that the stretched basis vectors are $S\vec{e}_1=\begin{bmatrix}\answer{1} \\ 0 \end{bmatrix}$ and $S\vec{e}_2=\begin{bmatrix} 0 \\ \answer{2} \end{bmatrix}$.

    Whereas the rotation matrix $R=\begin{bmatrix} \cos 60 & -\sin 60 \\ \sin 60 & \cos 60 \end{bmatrix}$ would normally tell us where to map $\vec{e}_1$ and $\vec{e}_2$, to continue the tansformation we instead need to apply the matrix to $S\vec{e}_1$ and $S\vec{e}_2$.

    \begin{hint}\name{Notation}

        Don't let the notation fool you, $S\vec{e}_1$ and $S\vec{e}_2$ vectors, not matrices. Remember that multiplying a matrix by a vector gives you a transformed vector.

    \end{hint}

    \begin{question}

        What are the rotated vectors $RS\vec{e}_1$ and $RS\vec{e}_2$?

        \begin{solution}

            We have $S\vec{e}_1=\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $S\vec{e}_2=\begin{bmatrix} 0 \\ 2 \end{bmatrix}$.

            Applying the rotation matrix $R$ to $S\vec{e}_1$ gives us $R(S\vec{e}_1)=\begin{bmatrix} \cos 60 & -\sin 60 \\ \sin 60 & \cos 60 \end{bmatrix}\begin{bmatrix} 1 \\ 0 \end{bmatrix}=\answer{1}\begin{bmatrix} \cos 60 \\ \sin 60 \end{bmatrix}+\answer{0}
            \begin{bmatrix} -\sin 60 \\ \cos 60 \end{bmatrix}=\begin{bmatrix} \cos 60 \\ \sin 60 \end{bmatrix}$.

            Applying the rotation matrix $R$ to $S\vec{e}_2$ gives us $R(S\vec{e}_2)=\begin{bmatrix} \cos 60 & -\sin 60 \\ \sin 60 & \cos 60 \end{bmatrix}\begin{bmatrix} 0 \\ 2 \end{bmatrix}=\answer{0}\begin{bmatrix} \cos 60 \\ \sin 60 \end{bmatrix}+\answer{2}
            \begin{bmatrix} -\sin 60 \\ \cos 60 \end{bmatrix}=\begin{bmatrix} -2\sin 60 \\ 2\cos 60 \end{bmatrix}$.

        \end{solution}

    \end{question}

    Putting this together, we see that the composite transformation matrix $RS$ is 
    
    $$RS=\begin{bmatrix} \cos 60 & -2\sin 60 \\ \sin 60 & 2\cos 60 \end{bmatrix}.$$

    Let's check that this matrix gives us the same result as the two transformations in sequence.

    Use the following MATLAB code to apply the composite transformation to the original smiley face.

    \begin{verbatim}

        load +linalg/face_points.mat

        RS = [cosd(60) -2*sind(60); sind(60) 2*cosd(60)];
        for i=1:length(face_points)
            face_points(i,:)=RS*face_points(i,:)';
        end
        linalg.plot_img_points(face_points)
    \end{verbatim}

    This yields the same smiley face as the two transformations in sequence!


    \end{example}

    \begin{remark}

        Note also that the notation we used to find the new basis vectors, $RS\vec{e}_1$ and $RS\vec{e}_2$ feels quite similar to notation used for scalar multiplication. For instance if $a=3$ and $b=4$ we would write $ab$ to mean $3\cdot 4$.

        This gives rise to the following definition of \emph{matrix multiplication}

        \begin{definition}

            Let $A$ be an $m\times n$ matrix and $B$ be an $n\times p$ matrix. The product $AB$ is an $m\times p$ matrix whose columns are given by 

            $$AB=\begin{bmatrix} A\vec{b}_1 & A\vec{b}_2 & \cdots & A\vec{b}_p \end{bmatrix}$$

            where $\vec{b}_1,\vec{b}_2,\ldots,\vec{b}_p$ are the columns of $B$.

        \end{definition}

        There is another, more standard definition of matrix multiplication that you'll often see in textbooks, which breaks down the operation for each entry rather than at each column. It's worth noting for efficiency, and that you'll see it in other contexts, however thinking about it as a column-wise operation is a good way to understand why matrix multiplication works the way it does.

        \begin{definition}\name{Entry-Wise Matrix Multiplication}

            Let $A$ be an $m\times n$ matrix and $B$ be an $n\times p$ matrix. The product $AB$ is an $m\times p$ matrix whose entries are given by 

            $$(AB)_{ij}=\sum_{k=1}^n A_{ik}B_{kj}.$$
        \end{definition}

    \end{remark}

    As usual, MATLAB has a built-in function for matrix multiplication, \texttt{A*B}, which will give you the same result as the column-wise definition of matrix multiplication. Let's check it on the previous example.

    \begin{example}

        Let's use MATLAB to check that the matrix $RS$ we found earlier is the same as the product of the matrices $R$ and $S$.

        \begin{verbatim}

            R = [cosd(60) -sind(60); sind(60) cosd(60)]
            S = [1 0; 0 2]
            RS = R*S
            RS
        \end{verbatim}

        This should yield the matrix $RS$ we found earlier, $\begin{bmatrix} \cos 60 & -2\sin 60 \\ \sin 60 & 2\cos 60 \end{bmatrix}$.
    \end{example}

    \begin{example}

        We're finally able to do all three of the transformations we initial set out to do: a vertical stretch by a factor of $2$, a $60^\circ$ rotation, and a reflection about the $y$-axis.

        Let's do it first in sequence, then as one transformation, and compare the results.

        \begin{enumerate}

            \item In Sequence: We already know the matrices for the stretch and rotation are $S=\begin{bmatrix} 1 & 0 \\ 0 & 2 \end{bmatrix}$ and $R=\begin{bmatrix} \cos 60 & -\sin 60 \\ \sin 60 & \cos 60 \end{bmatrix}$. The matrix for the reflection is $F=\begin{bmatrix} \answer{-1} & 0 \\ 0 & \answer{1} \end{bmatrix}$.
            
            Let's apply the transformations in sequence using MALTAB. 
            
            \begin{hint}\name{MATLAB}
            
            NOTE: The code will do it all in one for loop rather than three, but notice that each line within the for loop is applying each separate transformation to the smiley face points. 
            
            So first it will stretch the points, then the next line will rotate the already stretched points, then the next line will reflect the already stretched and rotated points.

            \end{hint}



            \texttt{load +linalg/face\textunderscore points.mat}

            \texttt{S = [1 0; 0 2]}

            \texttt{R = [cosd(60) -sind(60); sind(60) cosd(60)]}

            \texttt{F = [-1 0; 0 1]}

            \texttt{for i=1:length(face\textunderscore points)}

            \texttt{    face\textunderscore points(i,:)=}$\answer[format=string]{S}$\texttt{*face\textunderscore points(i,:)';}

            \texttt{        face\textunderscore points(i,:)=}$\answer[format=string]{R}$\texttt{*face\textunderscore points(i,:)';}

            \texttt{        face\textunderscore points(i,:)=}$\answer[format=string]{F}$\texttt{*face\textunderscore points(i,:)';}

            \texttt{end}

            \texttt{linalg.plot\textunderscore img\textunderscore points(face\textunderscore points)}

            \item Now we can do the same thing, but as one transformation. We'll call the composite matrix $M$.
            
            \vspace{1cm}
            
            \texttt{load +linalg/face\textunderscore points.mat}

            \texttt{R = [cosd(60) -sind(60); sind(60) cosd(60)]}

            \texttt{S = [1 0; 0 2]}

            \texttt{F = [-1 0; 0 1]}

            \texttt{M = }$\answer[format=string]{F}*\answer[format=string]{R}*\answer[format=string]{S}$

            \texttt{for i=1:length(face\textunderscore points)}

            $\qquad $\texttt{face\textunderscore points(i,:) = }$\answer[format=string]{M}$\texttt{*face\textunderscore points(i,:)';}

            \texttt{end}

            \texttt{linalg.plot\textunderscore img\textunderscore points(face\textunderscore points)}

        \end{enumerate}

        Hopefully both approaches got you the following:

        \begin{center}
            \includegraphics[width=\textwidth]{face_stretch_rotate_reflect.png}
        \end{center}

    \end{example}

\end{exploration}

\begin{exploration}\name{Properties of Matrix Multiplication}

    One might expect that, with how much more nuanced matrix multiplication and matrix-vector multiplication are compared to scalar multiplication, that there would be some extra rules and constraints.

    We'll explore these below.

    \begin{example}\name{Allowed mulitplications}

        Whereas we can multiply any scalar by another scalar (unelss we divide by zero), the same is not true for matrices, and also for matrix-vector multiplication.

        The key consideration is that matrices transform vectors in $\R^n$ to vectors in $\R^m$, and so we need to make sure that the matrices are defined to take in $n$-dimensional vectors and output $m$-dimensional vectors.

        Let's use some mapping diagrams to illustrate this for the $3\times 2$ matrix \(M=\begin{bmatrix} 1 & 2 \\ 2&-1 \\ 1 & 1\end{bmatrix}\)

        If $\vec{v}= \begin{bmatrix} 2 \\ 3 \end{bmatrix}$, then $M\vec{v}$ is calculated by $M\vec{v}=2 \begin{bmatrix} 1 \\ 2 \\ 1 \end{bmatrix}+3 \begin{bmatrix} 2 \\ -1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2+6 \\ 4-3 \\ 2+3 \end{bmatrix}=\begin{bmatrix} 8 \\ 1 \\ 5 \end{bmatrix}$.

        Since the columns of $M$ are $3$-dimensional, the result is a $3$-dimensional vector (one for each vector in the linear combination). Since the rows of $M$ are $2$-dimensional, the input vector must be $2$-dimensional (one for each scalar in the linear combination).

        By contrast, if $\vec{v}= \begin{bmatrix} 2 \\ 3 \\ 4 \end{bmatrix}$, then $M\vec{v}$ does not make sense because there isn't a third column of $M$ to multiply by the third entry of $\vec{v}$.

        \begin{tikzpicture}

            % Draw sets X, X'
            \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);
            \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);
        
            % Labels for sets X, X'
            \node at (-4,1.8) {\(\mathbb{R}^2\)};
            \node at (0,1.8) {\(\mathbb{R}^3\)};
        
            % Elements inside sets
            \filldraw[red] (-3,0) circle (3pt) node[below] {\textbf{v}};
            \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{Mv}};
        
            % Arrows for the transformation S
            \draw[->, thick, purple] (-3,0.2) .. controls (-1,1.2) .. (1,.7) node[midway, below] {\(M\)};
            
        \end{tikzpicture}

        Detemrine which of the following multiplications make sense, and why.

        $M=\begin{bmatrix} 1 & 2 \\ 2&-1 \\ 1 & 1\end{bmatrix}$, $N=\begin{bmatrix} 1 & 2 & 3 \\ 2&-1 & 0 \\ 1 & 1 & 1\end{bmatrix}$, $P=\begin{bmatrix} 1 & 2 \\ 2&-1 \\ 1 & 1 \\ 0 & 0\end{bmatrix}$

        $v=\begin{bmatrix} 2 \\ 3 \end{bmatrix}$,
        $w=\begin{bmatrix} 2 \\ 3 \\ 4 \end{bmatrix}$, $u=\begin{bmatrix} 2 \\ 3 \\ 4 \\ 5 \end{bmatrix}$

        Select all products that are allowed, make sure that the dimensional description is also correct.

        \begin{selectAll}

            \choice[correct]{$Mv$ is a $3$-dimensional vector}
            \choice{$Mv$ is a $2$-dimensional vector}
            \choice{$Mw$ is a $3$-dimensional vector}
            \choice{$Mw$ is a $2$-dimensional vector}
            \choice{$Mu$ is a $4$-dimensional vector}
            \choice{$Mu$ is a $3$-dimensional vector}
            \choice{$Nv$ is a $3$-dimensional vector}
            \choice{$Nv$ is a $2$-dimensional vector}
            \choice[correct]{$Nw$ is a $3$-dimensional vector}
            \choice{$Nw$ is a $2$-dimensional vector}
            \choice{$Nu$ is a $4$-dimensional vector}
            \choice{$Nu$ is a $3$-dimensional vector}
            \choice[correct]{$Pv$ is a $4$-dimensional vector}
            \choice{$Pv$ is a $3$-dimensional vector}
            \choice{$Pw$ is a $4$-dimensional vector}
            \choice{$Pw$ is a $3$-dimensional vector}
            \choice{$Pu$ is a $4$-dimensional vector}
            \choice{$Pu$ is a $3$-dimensional vector}
        \end{selectAll}

        \begin{solution}

            The matrix $M=\begin{bmatrix} 1 & 2 \\ 2&-1 \\ 1 & 1\end{bmatrix}$ is $3\times 2$, so it can only multiply $2$-dimensional vectors. $Mv$ produces a $3$-dimensional vector from its $3$ rows. 

            \begin{tikzpicture}

                % Draw sets X, X'
                \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);
                \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);
            
                % Labels for sets X, X'
                \node at (-4,1.8) {\(\mathbb{R}^2\)};
                \node at (0,1.8) {\(\mathbb{R}^3\)};
            
                % Elements inside sets
                \filldraw[red] (-3,0) circle (3pt) node[below] {\textbf{v}};
                \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{Mv}};
            
                % Arrows for the transformation S
                \draw[->, thick, purple] (-3,0.2) .. controls (-1,1.2) .. (1,.7) node[midway, below] {\(M\)};
                
            \end{tikzpicture}

            The matrix $N=\begin{bmatrix} 1 & 2 & 3 \\ 2&-1 & 0 \\ 1 & 1 & 1\end{bmatrix}$ is a $3\times 3$ matrix,
            so it can only multiply $3$-dimensional vectors. $Nw$ produces a $3$-dimensional vector from its $3$ rows.

            \begin{tikzpicture}

                % Draw sets X, X'
                \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);
                \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);
            
                % Labels for sets X, X'
                \node at (-4,1.8) {\(\mathbb{R}^3\)};
                \node at (0,1.8) {\(\mathbb{R}^3\)};
            
                % Elements inside sets
                \filldraw[red] (-3,0) circle (3pt) node[below] {\textbf{w}};
                \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{Nw}};
            
                % Arrows for the transformation N
                \draw[->, thick, purple] (-3,0.2) .. controls (-1,1.2) .. (1,.7) node[midway, below] {\(N\)};
            
            \end{tikzpicture}

            The matrix $P=\begin{bmatrix} 1 & 2 \\ 2&-1 \\ 1 & 1 \\ 0 & 0\end{bmatrix}$ is $4\times 2$, so it can only multiply $2$-dimensional vectors. $Pv$ produces a $4$-dimensional vector from its $4$ rows.

            \begin{tikzpicture}

                % Draw sets X, X'
                \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);
                \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);
            
                % Labels for sets X, X'
                \node at (-4,1.8) {\(\mathbb{R}^2\)};
                \node at (0,1.8) {\(\mathbb{R}^4\)};
            
                % Elements inside sets
                \filldraw[red] (-3,0) circle (3pt) node[below] {\textbf{v}};
                \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{Pv}};
            
                % Arrows for the transformation P
                \draw[->, thick, purple] (-3,0.2) .. controls (-1,1.2) .. (1,.7) node[midway, below] {\(P\)};
            
            \end{tikzpicture}

        \end{solution}

        With matrix multiplication, you have to smimilalry consider the dimensions of the vectors after each successive multiplication. You simply need to apply the same reasoning as matrix-vector mulitplication, but keep in mind the dimensions of the output vectors from the first product. If we take the matrices $M$ and $N$ from the previous example, $MN$ would not be allowed because the output of $N$ is $3$-dimensional, and the input of $M$ is $2$-dimensional, so the product would not be defined. 

        $NM$, however, would be allowed because the output of $M$ is $3$-dimensional, and the input of $N$ is $3$-dimensional, so the product would be defined.

        \begin{tikzpicture}

            % Draw sets X, X', and X''
            \draw[fill=yellow!20!white, draw=black, thick] (-4,0) ellipse (1.5cm);  % First ellipse (R^2)
            \draw[fill=green!20!white, draw=black, thick] (0,0) ellipse (1.5cm);    % Second ellipse (R^4)
            \draw[fill=cyan!20!white, draw=black, thick] (4,0) ellipse (1.5cm);     % Third ellipse (R^3)
        
            % Labels for sets X, X', X''
            \node at (-4,1.8) {\(\mathbb{R}^2\)};
            \node at (0,1.8) {\(\mathbb{R}^3\)};
            \node at (4,1.8) {\(\mathbb{R}^3\)};
        
            % Elements inside sets
            \filldraw[red] (-5,0) circle (3pt) node[below] {\textbf{v}};  % Vector in R^2
            \filldraw[red] (1,.5) circle (3pt) node[below] {\textbf{Pv}}; % Vector in R^4
            \filldraw[red] (5,-.5) circle (3pt) node[below] {\textbf{NPv}}; % Vector in R^3
        
            % Arrows for the transformations P and N
            \draw[->, thick, purple] (-5,0.2) .. controls (-2,1.2) .. (1,.7) node[midway, below] {\(M\)};
            \draw[->, thick, purple] (1,.7) .. controls (2,1.2) .. (5,-.3) node[midway, below] {\(N\)};
        
        \end{tikzpicture}

        Now determine which of the following matrix products is allowed, and why, using the matrices %make a 2x3, 3x4, 2x2, 3x3 matrices
        $M=\begin{bmatrix} 1 & 2 & 1\\ 2&-1 &0\end{bmatrix}$, $N=\begin{bmatrix} 1 & 2 & 3 \\ 2&-1 & 0 \\ 1 & 1 & 1 \\ 0 & 0 & 0\end{bmatrix}$, $P=\begin{bmatrix} 1 & 2 \\ 2&-1 \end{bmatrix}$, $Q=\begin{bmatrix} 1 & 2 & 3 \\ 2&-1 & 0 \\ 1 & 1 & 1\end{bmatrix}$.


        \begin{selectAll}

            \choice{$MN$}
            \choice[correct]{$MN^T$}
            \choice{$NM$}
            \choice{$NM^T$}
            \choice{$MP$}
            \choice[correct]{$M^TP$}
            \choice{$PQ$}
            \choice{$QP$}
            \choice{$PQ^T$}
            \choice[correct]{$NQ$}
            \choice{$N^TQ$}
            \choice[correct]{$PM$}

        \end{selectAll}

        \begin{solution}
        
            $N^T$ is a $3\times 4$ matrix, so it outputs a $3$-dimensional vector. $M$ is a $2\times 3$ matrix, so it takes in a $3$-dimensional vector and thus the product $MN^T$ is allowed.

            $P$ is a $2\times 2$ matrix, so it outputs a $2$-dimensional vector. $M^T$ is a $3\times 2$ matrix, so it takes in a $2$-dimensional vector and thus the product $M^TP$ is allowed.

            $Q$ is a $3\times 3$ matrix, so it outputs a $3$-dimensional vector. $N$ is a $4\times 3$ matrix, so it takes in a $3$-dimensional vector and thus the product $NQ$ is allowed.

            $M$ is a $2\times 3$ matrix, so it outputs a $2$-dimensional vector. $P$ is a $2\times 2$ matrix, so it takes in a $2$-dimensional vector and thus the product $PM$ is allowed.

        \end{solution}

    \end{example}

    \begin{example}\name{Commutativity}

        Scalar multiplication is commutative, meaning you can swap the order of any numbers in the product and still get the same result.

        For instance, $3\cdot 4\cdot 5\cdot 2=2\cdot 5\cdot 4\cdot 3=4\cdot 3\cdot 5\cdot 2=120$.

        Let's check whether we can do the same for matrix multiplication. In our past example, we got the composite matrix $M=FRS$, a stretch by $2$, a $60^\circ$ rotation, and a reflection about the $y$-axis.

        If matrix multiplication is commutative, then the matrices $FSR$ and $RFS$ should give us the same result as $M$, since it wouldn't matter what order we multiplied the matrices in.

        Do this in MATLAB and match the results of each product.

        \begin{hint}

            You can use the same code as before, but just change the order of the matrices in the product. Match each figure to the matrices that produced them.

        \end{hint}

        % Include the FSR image
        \begin{figure}[ht!]
            \centering
            \includegraphics[width=\textwidth]{fsr.png}
            \caption{(a)}
        \end{figure}
        
        \begin{selectAll}

            \choice[correct]{$FSR$}
            \choice{$RSF$}
            \choice[correct]{$SFR$}
            \choice{$SRF$}

        \end{selectAll}

        % Include the SRF image
        \begin{figure}[ht!]
            \centering
            \includegraphics[width=\textwidth]{srf.png}
            \caption{(c)}
        \end{figure}

        \begin{selectAll}

            \choice{$FSR$}
            \choice{$RSF$}
            \choice{$SFR$}
            \choice[correct]{$SRF$}           

        \end{selectAll}

        % Include the RSF image
        \begin{figure}[ht!]
            \centering
            \includegraphics[width=\textwidth]{rsf.png}
            \caption{(d)}
        \end{figure}

        \begin{selectAll}

            \choice{$FSR$}
            \choice[correct]{$RSF$}
            \choice{$SFR$}
            \choice{$SRF$}

        \end{selectAll}

    As we can see, while there is some overlap, different orders of matrix multiplication produced different transformations of the inptu vectors in $\R^2$. We have to conclude that the ordering matters for matrix multiplication, and so \emph{matrix multiplication is not commutative}.

    \end{example}

    \begin{example}\name{Associativity}

        Associativity regards the order in which each pair of operations is carried out. For instance, $(3\cdot 4)\cdot 5=12\cdot 5=60$, and $3\cdot (4\cdot 5)=3\cdot 20=60$, so even though we carried out each multiplication in a different order, we still got the same result.

        Is this also true for matrices? Let's check.

        Use the following code, which computes each pair of matrices before the for loop, and then apply the pairs in different orders to check for associativity.

        First, compute $F(RS)$.

        \vspace{1cm}


\texttt{load +linalg/face\textunderscore points.mat}

\texttt{R = [cosd(60) -sind(60); sind(60) cosd(60)]}

\texttt{S = [1 0; 0 2]}

\texttt{F = [-1 0; 0 1]}

\texttt{RS = }$\answer[given,format=string]{R}*\answer[format=string]{S}$

\texttt{FR = }$\answer[given,format=string]{F}*\answer[format=string]{R}$

\texttt{for i=1:length(face\textunderscore points)}

$\qquad $\texttt{face\textunderscore points(i,:) = }$\answer[given,format=string]{RS}$\texttt{*face\textunderscore points(i,:)';}

$\qquad $\texttt{face\textunderscore points(i,:) = }$\answer[format=string]{F}$\texttt{*face\textunderscore points(i,:)';}

\texttt{end}

\texttt{linalg.plot\textunderscore img\textunderscore points(face\textunderscore points)}

\vspace{1cm}

        Then, compute $(FR)S$.

        \vspace{1cm}

\texttt{for i=1:length(face\textunderscore points)}

$\qquad $\texttt{face\textunderscore points(i,:) = }$\answer[given,format=string]{S}$\texttt{*face\textunderscore points(i,:)';}

$\qquad $\texttt{face\textunderscore points(i,:) = }$\answer[format=string]{FR}$\texttt{*face\textunderscore points(i,:)';}

$\texttt{end}$

\texttt{linalg.plot\textunderscore img\textunderscore points(face\textunderscore points)}

\vspace{1cm}

These should all give you the same smiley face that we originally stretched, rotated, and reflected.

So, matrix multiplicaiton \emph{is associative}.

    \end{example}

\end{exploration}

\begin{remark}

    As we continue to learn more properties of matrices, and which matrices are useful for solving various problems, remember that most (if not all) of the powerful things that we can do with matrices boil down to the understanding of matrices as linear transformations.

\end{remark}

There's a lot to review, and we'll be doing much more with linear transformations moving forward. Here's a helpful summary from Grant Sanderson:

\youtube{kYB8IZa5AuE?si=pfb2PjvAwHiPSl5X}

\end{document}